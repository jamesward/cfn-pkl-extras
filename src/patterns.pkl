module `cfn-pkl-extras`.patterns

import "pkl:Project"
import "@cfn/cloudformation.pkl" as cfn
import "@cfn/aws/lambda/function.pkl" as lambdafunction
// import "@cfn/patterns/role.pkl" as role
import "@cfn/aws/iam/role.pkl" as role
import "@cfn/aws/route53/recordset.pkl" as recordset
import "@cfn/aws/route53/hostedzone.pkl" as hostedzone
import "@cfn/aws/s3/bucket.pkl" as bucket
import "@cfn/aws/s3/bucketpolicy.pkl" as bucketpolicy
import "@cfn/aws/cloudfront/distribution.pkl" as distribution
import "@cfn/aws/cloudfront/originaccesscontrol.pkl" as originaccesscontrol
import "@cfn/aws/cloudfront/function.pkl" as cloudfrontFunction
import "@cfn/aws/certificatemanager/certificate.pkl" as certificate
// import "package://pkg.pkl-lang.org/github.com/aws-cloudformation/cloudformation-pkl/cloudformation@0.1.4#/aws/certificatemanager/certificate.pkl" as certificate


// todo:
//  - lifecycle on HostedZoneManager doesn't work for cleaning up HostedZone



// todo: must not start with a number?
const resourceNameClases = "A-Za-z0-9"
const resourceNameRegex = Regex("[\(resourceNameClases)]+")
const resourceNameInvalidRegex = Regex("[^\(resourceNameClases)]")

typealias ResourceName = String(matches(resourceNameRegex), length < 256)

const domainNameRegex = #"(?!-)[A-Za-z0-9-]{1,63}(?<!-)(\.[A-Za-z0-9-]{1,63}(?<!-))*\.[A-Za-z]{2,}"#

const local validDomainNameRegex: Regex = Regex("^\(domainNameRegex)$")

typealias ValidDomainName = String(matches(validDomainNameRegex))

class DomainName {
  name: ValidDomainName
  hidden resourceName: ResourceName = name.replaceAll(resourceNameInvalidRegex, "")

  // causes StackOverflow
  //  fixed apex: DomainName = new DomainName { name = parts.takeLast(2).join(".") }
  hidden apex: String = name.split(".").takeLast(2).join(".")
  hidden apexResourceName: ResourceName = apex.replaceAll(resourceNameInvalidRegex, "")
}


class DomainTemplate {
  resources: Mapping<ResourceName, cfn.Resource>
  outputs: Mapping<ResourceName, cfn.Output>
}

//   ["domain"] = new {
//     Type = "AWS::Route53::RegisteredDomain"
//     Properties = new Mapping {
//       ["DomainName"] = "jamesward.me"
//
//     }
//   }

// ["RecordSetAAAA"] = new recordset.RecordSet {
//   HostedZoneId = cfn.Ref("HostedZone")
//   Name = domainname
//   TypeProperty = "AAAA"
//   AliasTarget {
//     // The following HosteZoneId is always used for alias records pointing to CF.
//     HostedZoneId = "Z2FDTNDATAQYW2"
//     //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
//     DNSName = cfn.GetAtt("Distribution", "DomainName")
//     EvaluateTargetHealth = false
//   }
// }

// todo: no union types in java/kotlin code generator

// todo: phone constraints
typealias Phone = String

typealias NonEmptyString = String(!isEmpty)

typealias ContactType = "PERSON"|"COMPANY"|"ASSOCIATION"|"PUBLIC_BODY"|"RESELLER"

typealias CountryCode = "AC"|"AD"|"AE"|"AF"|"AG"|"AI"|"AL"|"AM"|"AN"|"AO"|"AQ"|"AR"|"AS"|"AT"|"AU"|"AW"|"AX"|"AZ"|"BA"|"BB"|"BD"|"BE"|"BF"|"BG"|"BH"|"BI"|"BJ"|"BL"|"BM"|"BN"|"BO"|"BQ"|"BR"|"BS"|"BT"|"BV"|"BW"|"BY"|"BZ"|"CA"|"CC"|"CD"|"CF"|"CG"|"CH"|"CI"|"CK"|"CL"|"CM"|"CN"|"CO"|"CR"|"CU"|"CV"|"CW"|"CX"|"CY"|"CZ"|"DE"|"DJ"|"DK"|"DM"|"DO"|"DZ"|"EC"|"EE"|"EG"|"EH"|"ER"|"ES"|"ET"|"FI"|"FJ"|"FK"|"FM"|"FO"|"FR"|"GA"|"GB"|"GD"|"GE"|"GF"|"GG"|"GH"|"GI"|"GL"|"GM"|"GN"|"GP"|"GQ"|"GR"|"GS"|"GT"|"GU"|"GW"|"GY"|"HK"|"HM"|"HN"|"HR"|"HT"|"HU"|"ID"|"IE"|"IL"|"IM"|"IN"|"IO"|"IQ"|"IR"|"IS"|"IT"|"JE"|"JM"|"JO"|"JP"|"KE"|"KG"|"KH"|"KI"|"KM"|"KN"|"KP"|"KR"|"KW"|"KY"|"KZ"|"LA"|"LB"|"LC"|"LI"|"LK"|"LR"|"LS"|"LT"|"LU"|"LV"|"LY"|"MA"|"MC"|"MD"|"ME"|"MF"|"MG"|"MH"|"MK"|"ML"|"MM"|"MN"|"MO"|"MP"|"MQ"|"MR"|"MS"|"MT"|"MU"|"MV"|"MW"|"MX"|"MY"|"MZ"|"NA"|"NC"|"NE"|"NF"|"NG"|"NI"|"NL"|"NO"|"NP"|"NR"|"NU"|"NZ"|"OM"|"PA"|"PE"|"PF"|"PG"|"PH"|"PK"|"PL"|"PM"|"PN"|"PR"|"PS"|"PT"|"PW"|"PY"|"QA"|"RE"|"RO"|"RS"|"RU"|"RW"|"SA"|"SB"|"SC"|"SD"|"SE"|"SG"|"SH"|"SI"|"SJ"|"SK"|"SL"|"SM"|"SN"|"SO"|"SR"|"SS"|"ST"|"SV"|"SX"|"SY"|"SZ"|"TC"|"TD"|"TF"|"TG"|"TH"|"TJ"|"TK"|"TL"|"TM"|"TN"|"TO"|"TP"|"TR"|"TT"|"TV"|"TW"|"TZ"|"UA"|"UG"|"US"|"UY"|"UZ"|"VA"|"VC"|"VE"|"VG"|"VI"|"VN"|"VU"|"WF"|"WS"|"YE"|"YT"|"ZA"|"ZM"|"ZW"

class Contact {
  firstName: NonEmptyString
  lastName: NonEmptyString
  type: ContactType
  addressLine1: NonEmptyString
  city: NonEmptyString
  state: NonEmptyString
  countryCode: CountryCode
  zipCode: UInt32
  phoneNumber: Phone
  email: Project.EmailAddress
}

class Domain {
  domainName: DomainName
  contact: Contact
  transferAuthCode: (String | Mapping)?
  nameServers: Listing<ValidDomainName>
  autoRenew: Boolean

  hidden resources: Mapping<ResourceName, cfn.Resource> = new Mapping<ResourceName, cfn.Resource> {
    ["\(domainName.apexResourceName)Domain"] = new cfn.Resource {
      Type = "AWS::CloudFormation::CustomResource"
      Properties = new Mapping {
        ["ServiceToken"] = cfn.GetAtt("RegisteredDomainFunction", "Arn")
        ["ServiceTimeout"] = 10
        ["DomainName"] = domainName.apex
        ["Contact"] = contact
        ["TransferAuthCode"] = transferAuthCode
        when (!nameServers.isEmpty) {
          ["NameServers"] = nameServers
        }
        ["AutoRenew"] = autoRenew
      }
    }
  }
}

typealias DomainRecordType = "A" | "AAAA" | "CNAME" | "TXT" | "MX" | "NS" | "SOA" | "SRV" | "PTR" | "CAA" | "DNSKEY" | "DS" | "NAPTR" | "SSHFP" | "TLSA"


// function fromName(domainName: String) =
//   make(new Domain { name = domainName })
//
// function make(domain: Domain): DomainTemplate =
//   new {
//     resources = new Mapping<ResourceName, cfn.Resource> {
//       ["\(resourceName)HostedZone"] = new hostedzone.HostedZone {
//         Name = domain.name
//       }
//       ["\(resourceName)RecordSetGroup"] = new recordsetgroup.RecordSetGroup {
//         HostedZoneId = cfn.Ref("\(resourceName)HostedZone")
//         RecordSets {
//           new {
//             Name = domain.name
//             Type = domain.type
//             TTL = domain.ttl.toString()
//             ResourceRecords = domain.records
//           }
//         }
//       }
//     }
//     outputs = new Mapping<ResourceName, cfn.Output> {
//       ["\(resourceName)NameServers"] = new {
//         Value = new Mapping {
//           ["Fn::Join"] = new Listing {
//             ","
//             cfn.GetAtt("\(resourceName)HostedZone", "NameServers")
//           }
//         }
//         Export {
//           Name = cfn.Sub("${AWS::StackName}-NameServers")
//         }
//       }
//     }
//   }

// hidden const registeredDomainFunctionRole = new role.Role {
//   AssumeRolePolicyDocument {
//     Statement {
//       Effect = "Allow"
//       Principal {
//         Service = "lambda.amazonaws.com"
//       }
//       Action = "sts:AssumeRole"
//     }
//   }
//   ManagedPolicyArns {
//     "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
//     "arn:aws:iam::aws:policy/AmazonRoute53DomainsFullAccess"
//   }
// }

hidden const domainFunctionRole = new role.Role {
  AssumeRolePolicyDocument {
    Statement {
      Effect = "Allow"
      Principal {
        Service = "lambda.amazonaws.com"
      }
      Action = "sts:AssumeRole"
    }
  }
  ManagedPolicyArns {
    "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    "arn:aws:iam::aws:policy/AmazonRoute53DomainsFullAccess"
  }
  Policies {
    new {
      PolicyName = "DomainFunctionRoleHostedZonePolicy"
      PolicyDocument {
        Version = "2012-10-17"
        Statement = new Listing {
          new {
            Effect = "Allow"
            Action = new Listing {
              "route53:GetHostedZone"
              "route53:ListResourceRecordSets"
              "route53:ChangeResourceRecordSets"
              "route53:DeleteHostedZone"
              "route53domains:UpdateDomainNameservers"
            }
            Resource = cfn.Sub("arn:aws:route53:::hostedzone/*")
          }
        }
      }
    }
  }
}

// todo: ManagedPolicyArns
// hidden const registeredDomainFunctionRole = new role {
//   LogicalId = "RegisterdDomainFunctionRole"
//   AssumeService = "lambda.amazonaws.com"
//   Permits = new role.Statement {
//     Action = new Listing<String> {
//       "logs:CreateLogGroup"
//       "logs:CreateLogStream"
//       "logs:PutLogEvents"
//     }
//     Resource = cfn.Arn("logs", ":log-group:/aws/lambda/*")
//   }
// }

// CleanupHostedZoneFunctionRolePolicy: Resource handler returned message: "The role with name CleanupHostedZoneFunctionRole cannot be found.

// hidden const cleanupHostedZoneFunctionRole = (role) {
//   LogicalId = "CleanupHostedZoneFunctionRole"
//   AssumeService = "lambda.amazonaws.com"
//   Statements = new role.Statement {
//     Action = new Listing<role.RefString> {
//       "route53:ListResourceRecordSets"
//       "route53:ChangeResourceRecordSets"
//       "route53:DeleteHostedZone"
//     }
//     Resource = cfn.Sub("arn:aws:route53:::hostedzone/*")
//   }
// }

// hidden const hostedZoneFunctionRole = new role.Role {
//   AssumeRolePolicyDocument {
//     Statement {
//       Effect = "Allow"
//       Principal {
//         Service = "lambda.amazonaws.com"
//       }
//       Action = "sts:AssumeRole"
//     }
//   }
//
//   ManagedPolicyArns {
//     "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
//   }
//
//   Policies {
//     new {
//       PolicyName = "CleanupHostedZoneFunctionRole"
//       PolicyDocument {
//         Version = "2012-10-17"
//         Statement = new Listing {
//           new {
//             Effect = "Allow"
//             Action = new Listing {
//               "route53:GetHostedZone"
//               "route53:ListResourceRecordSets"
//               "route53:ChangeResourceRecordSets"
//               "route53:DeleteHostedZone"
//               "route53domains:UpdateDomainNameservers"
//             }
//             Resource = cfn.Sub("arn:aws:route53:::hostedzone/*")
//           }
//         }
//       }
//     }
//     new {
//       PolicyName = "CreateUpdateHostedZoneFunctionRole"
//       PolicyDocument {
//         Version = "2012-10-17"
//         Statement = new Listing {
//           new {
//             Effect = "Allow"
//             Action = new Listing {
//               "route53:GetHostedZone"
//               "route53domains:UpdateDomainNameservers"
//             }
//             Resource = "*"
//           }
//         }
//       }
//     }
//   }
// }

const registerDomainCustomResource: Mapping<ResourceName, cfn.Resource> = new {

//   ...registeredDomainFunctionRole.Resources
  ["DomainFunctionRole"] = domainFunctionRole

  ["RegisteredDomainFunction"] = new lambdafunction.Function {
    Runtime = "python3.9"
    Handler = "index.handler"
    Timeout = 10
    //Role = cfn.GetAtt(registeredDomainFunctionRole.LogicalId, "Arn")
    Role = cfn.GetAtt("DomainFunctionRole", "Arn")
    Code {
      ZipFile = """
        import json
        import cfnresponse
        import boto3

        def handler(event, context):

          def contact():
            return {
                'FirstName': event['ResourceProperties']['Contact']['firstName'],
                'LastName': event['ResourceProperties']['Contact']['lastName'],
                'ContactType': event['ResourceProperties']['Contact']['type'],
                'AddressLine1': event['ResourceProperties']['Contact']['addressLine1'],
                'City': event['ResourceProperties']['Contact']['city'],
                'State': event['ResourceProperties']['Contact']['state'],
                'CountryCode': event['ResourceProperties']['Contact']['countryCode'],
                'ZipCode': event['ResourceProperties']['Contact']['zipCode'],
                'PhoneNumber': event['ResourceProperties']['Contact']['phoneNumber'],
                'Email': event['ResourceProperties']['Contact']['email'],
              }

          def nameServers():
            servers = event['ResourceProperties'].get('NameServers', [])
            return [{'Name': server} for server in servers]

          def autoRenew():
            return event['ResourceProperties']['AutoRenew']

          client = boto3.client('route53domains')

          try:
            domain_name = event['ResourceProperties']['DomainName']

            if event['RequestType'] == 'Create':
              transferAuthCode = event['ResourceProperties'].get('TransferAuthCode')

              def attemptRegister():
                availability = client.check_domain_availability(
                  DomainName = domain_name
                )

                if availability['Availability'] == 'AVAILABLE':
                  client.register_domain(
                    DomainName = domain_name,
                    DurationInYears = 1,
                    AutoRenew = autoRenew(),
                    AdminContact = contact(),
                    RegistrantContact = contact(),
                    TechContact = contact(),
                    PrivacyProtectAdminContact = True,
                    PrivacyProtectRegistrantContact = True,
                    PrivacyProtectTechContact = True
                  )

                  if nameServers():
                    client.update_domain_nameservers(
                      DomainName = domain_name,
                      Nameservers = nameServers()
                    )

                else:
                  raise Exception(f"Domain unavailable: {availability['Availability']}")

              def attemptTransfer():
                transferability = client.check_domain_transferability(
                  DomainName = domain_name,
                  AuthCode = transferAuthCode
                )

                print(f"Error: {str(transferability)}")

                if transferability['Transferability']['Transferable'] == 'TRANSFERABLE':
                  params = {
                    'DomainName': domain_name,
                    'AuthCode': transferAuthCode,
                    'DurationInYears': 1,
                    'AutoRenew': autoRenew(),
                    'AdminContact': contact(),
                    'RegistrantContact': contact(),
                    'TechContact': contact(),
                    'PrivacyProtectAdminContact': True,
                    'PrivacyProtectRegistrantContact': True,
                    'PrivacyProtectTechContact': True
                  }

                  if nameServers():
                    params['Nameservers'] = nameServers()

                  client.transfer_domain(**params)
                elif transferability['Transferability']['Transferable'] == 'DOMAIN_IN_OWN_ACCOUNT':
                  return
                elif transferability['Transferability']['Transferable'] == 'UNTRANSFERABLE':
                  return
                else:
                  raise Exception(f"Transferability: {transferability['Message']}")

              try:
                attemptRegister() if transferAuthCode is None else attemptTransfer()
              except client.exceptions.ClientError as e:
                print(f"Error: {str(e)}")

              responseData = {}
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, domain_name)

            elif event['RequestType'] == 'Update':

              try:
                domain_details = client.get_domain_detail(
                  DomainName = domain_name
                )

                status = domain_details.get('StatusList', [])
                pending_transfer = any('PENDING_TRANSFER' in s for s in status)

                def contacts_are_different(new_contact, old_contact):

                  print(f"New: {str(new_contact)}")
                  print(f"Old: {str(old_contact)}")

                  fields_to_compare = [
                    'FirstName',
                    'LastName',
                    'ContactType',
                    'OrganizationName',
                    'AddressLine1',
                    'AddressLine2',
                    'City',
                    'State',
                    'CountryCode',
                    'ZipCode',
                    'PhoneNumber',
                    'Email'
                  ]

                  for field in fields_to_compare:
                    if old_contact.get(field) != new_contact.get(field):
                      return True

                  return False

                if not pending_transfer:
                  updated_admin_contact = contacts_are_different(contact(), domain_details.get('AdminContact', {}))
                  updated_registrant_contact = contacts_are_different(contact(), domain_details.get('RegistrantContact', {}))
                  updated_tech_contact = contacts_are_different(contact(), domain_details.get('TechContact', {}))

                  if updated_admin_contact or updated_registrant_contact or updated_tech_contact:
                    client.update_domain_contact(
                      DomainName = domain_name,
                      AdminContact = contact(),
                      RegistrantContact = contact(),
                      TechContact = contact()
                    )

                  # todo: update autoRenew

                  # todo: if updated
                  if nameServers():
                    client.update_domain_nameservers(
                      DomainName = domain_name,
                      Nameservers = nameServers()
                    )

                responseData = {}
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, domain_name)

              except client.exceptions.ClientError as e:
                print(f"Error checking domain transfer status: {str(e)}")
                responseData = {}
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, domain_name)

            elif event['RequestType'] == 'Delete':
              responseData = {}
              try:
                client.get_domain_detail(
                  DomainName = domain_name
                )

                # How do we handle Delete? What about rollbacks? What about moving from one CFN to another? Maybe a field that confirms we actually want to delete it?
                # client.delete_domain(
                #  DomainName = domain_name
                # )

                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, domain_name)

              except client.exceptions.InvalidInput:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, domain_name)

            else:
              raise Exception(f'Invalid RequestType')

          except KeyError as e:
            print(f"Event: {event}")
            print(f"Context: {context}")
            error_message = f"Expected parameter not set: {str(e)}"
            responseData = {}
            cfnresponse.send(event, context, cfnresponse.FAILED, responseData, reason=error_message)

          except Exception as e:
            print(f"Error: {e}")
            print(f"Event: {event}")
            print(f"Context: {context}")
            error_message = f"An unexpected error occurred: {str(e)}"
            responseData = {}
            cfnresponse.send(event, context, cfnresponse.FAILED, responseData, reason=error_message)
        """
    }
  }

//   ...cleanupHostedZoneFunctionRole.Resources
//  ["HostedZoneFunctionRole"] = domainFunctionRole

  ["HostedZoneFunction"] = new lambdafunction.Function {
    Runtime = "python3.9"
    Handler = "index.handler"
    Timeout = 10
//     Role = cfn.Ref("CleanupHostedZoneFunctionRole")
    Role = cfn.GetAtt("DomainFunctionRole", "Arn")
//     Role = cfn.Ref(cleanupHostedZoneFunctionRole.LogicalId)
    Code {
      ZipFile = """
        import boto3
        import cfnresponse

        def handler(event, context):
          # TODO: Not sure what we are doing here and why
          # if event['RequestType'] in ['Create', 'Update']:
          #  try:
          #    route53 = boto3.client('route53')
          #    route53domains = boto3.client('route53domains')

          #    hosted_zone = route53.get_hosted_zone(Id=event['ResourceProperties']['HostedZoneId'])
          #    name_servers = hosted_zone['DelegationSet']['NameServers']

          #    route53domains.update_domain_nameservers(
          #      DomainName=event['ResourceProperties']['DomainName'],
          #      Nameservers=[{'Name': ns} for ns in name_servers]
          #    )

          #    cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
          #  except Exception as e:
          #    print(e)
          #    cfnresponse.send(event, context, cfnresponse.FAILED, {})

          if event['RequestType'] == 'Delete':
            try:
              route53 = boto3.client('route53')
              hosted_zone_id = event['ResourceProperties']['HostedZoneId']

              # Get all record sets
              record_sets = route53.list_resource_record_sets(HostedZoneId=hosted_zone_id)['ResourceRecordSets']

              # Delete all non-NS and non-SOA records
              for record in record_sets:
                if record['Type'] not in ['NS', 'SOA']:
                  route53.change_resource_record_sets(
                    HostedZoneId=hosted_zone_id,
                    ChangeBatch={
                      'Changes': [{
                        'Action': 'DELETE',
                        'ResourceRecordSet': record
                      }]
                    }
                  )

              # TODO: Trying to remove the retain
              # Delete the hosted zone
              # route53.delete_hosted_zone(Id=hosted_zone_id)

              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
            except Exception as e:
              print(e)
              cfnresponse.send(event, context, cfnresponse.FAILED, {})
          else:
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
        """
    }
  }
}

// function authCode(code: String): (ApexDomainName) -> ApexDomainNameWithAuthCode =
//   (domain: ApexDomainName) -> new ApexDomainNameWithAuthCode {
//     apexDomainName = domain
//     authCode = code
//   }

typealias ApexDomainName = String(matches(Regex(#"^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$"#)))
// class ApexDomainNameWithAuthCode {
//   apexDomainName: ApexDomainName
//   authCode: NonEmptyString
// }
//

class BasicRedirect {
  sub: String?
  to: Uri
  permanent: Boolean = false
  aliases: Listing<ValidDomainName>
}

class DomainRecord {
  sub: String?
  type: DomainRecordType
  ttl: Duration(this >= 30.s)?
  // todo: value: String | Listing<String>
  values: Listing<String>(!isEmpty)
}

// todo: can't have ghpages and redirect
class DomainDetails {
  authCode: (String | Mapping)?
  redirect: BasicRedirect?
  ghpages: String?
  records: Listing<DomainRecord>
  nameServers: Listing<ValidDomainName>
  autoRenew: Boolean = true
}

// the reason for the HostedZoneManager is because HostedZone can't be deleted when there are non-NS records associated with it
// and the Certificate creates an additional CNAME record which prevents deletion
const function hostedZone(domainName: DomainName): Mapping<ResourceName, cfn.Resource> =
  new {
    ["\(domainName.apexResourceName)HostedZone"] = new hostedzone.HostedZone {
      Name = domainName.apex
//       DeletionPolicy = "Retain"
    }

    ["\(domainName.apexResourceName)HostedZoneManager"] = new cfn.Resource {
      Type = "AWS::CloudFormation::CustomResource"
      Properties = new Mapping {
        ["ServiceToken"] = cfn.GetAtt("HostedZoneFunction", "Arn")
        ["DomainName"] = domainName.apex
        ["HostedZoneId"] = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      }
    }
  }

const function apexAndRecordToDomainName(apexDomain: ApexDomainName, domainRecord: DomainRecord): Pair<DomainName, DomainRecord> =
  let (key = if (domainRecord.sub != null) "\(domainRecord.sub).\(apexDomain)" else apexDomain)
    Pair(new DomainName { name = key }, domainRecord)

// const function domainsAndRecords(apexDomain: ApexDomainName, records: Listing<DomainRecord>): Mapping<ResourceName, DomainRecord> =
//   new {
//     for (domainRecord in records) {
//       [apexAndRecordToDomainName(apexDomain, domainRecord).resourceName + domainRecord.type] = domainRecord
//     }
//   }

const function domainRecords(apexDomain: ApexDomainName, records: Listing<DomainRecord>): Mapping<ResourceName, cfn.Resource> =
  new Mapping<ResourceName, cfn.Resource> {
    // todo: nicer
    for (domainNameAndRecord in records.toList().map((domainRecord) -> apexAndRecordToDomainName(apexDomain, domainRecord))) {
      ["\(domainNameAndRecord.first.resourceName)RecordSet\(domainNameAndRecord.second.type)"] = new recordset.RecordSet {
        HostedZoneId = cfn.Ref("\(domainNameAndRecord.first.apexResourceName)HostedZone")
        Name = domainNameAndRecord.first.name
        TypeProperty = domainNameAndRecord.second.type
        TTL = domainNameAndRecord.second.ttl?.toUnit("s")?.value?.toString() ?? "300" // default TTL
        ResourceRecords = domainNameAndRecord.second.values.toList().map((value) -> if (domainNameAndRecord.second.type == "TXT") "\"\(value)\"" else value).toListing()
      }
    }
  }

class Domains {
  contact: Contact
  //domains: Listing<ApexDomainName | ApexDomainNameWithAuthCode>
  domains: Mapping<ApexDomainName, DomainDetails>

//   function getDomainName(apexDomain: ApexDomainName | ApexDomainNameWithAuthCode): String =
//     new Mapping<Class, String> {
//       [String] = apexDomain as String
//       [ApexDomainNameWithAuthCode] = apexDomain.apexDomainName
//     }[apexDomain.getClass()]

//   function apexDomainToDomainResources(apexDomain: ApexDomainName | ApexDomainNameWithAuthCode): Mapping<ResourceName, cfn.Resource> =
//     let (_contact = contact)
//       new Domain {
//         domainName {
//           name = getDomainName(apexDomain)
//         }
//         contact = _contact
//         when (apexDomain is ApexDomainNameWithAuthCode) {
//           transferAuthCode = apexDomain.authCode
//         }
//       }.resources

  function apexDomainToDomain(apexDomain: ApexDomainName, domainDetails: DomainDetails): Domain =
    let (_contact = contact)
      new Domain {
        domainName {
          name = apexDomain
        }
        contact = _contact
        transferAuthCode = domainDetails.authCode
        nameServers = domainDetails.nameServers
        autoRenew = domainDetails.autoRenew
      }

  function apexDomainToResources(apexDomain: ApexDomainName, domainDetails: DomainDetails): Mapping<ResourceName, cfn.Resource> =
    if (domainDetails.redirect != null)
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        ...new WebSiteRedirect {
          domainName {
            name = domainDetails.redirect?.sub.ifNonNull((sub) -> "\(sub).\(apexDomain)") ?? apexDomain
          }
          redirect = domainDetails.redirect
          validationMethod = if (domainDetails.authCode != null) "EMAIL" else "DNS" // transferring domains takes a long time, blocking certification creation
        }.resources
        when (!domainDetails.records.isEmpty) {
          ...domainRecords(apexDomain, domainDetails.records)
        }
      }
    else if (domainDetails.ghpages != null)
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        ...hostedZone(new DomainName { name = apexDomain })
        ...domainRecords(apexDomain, new Listing<DomainRecord> {
          new {
            type = "A"
            values {
              "185.199.108.153"
              "185.199.109.153"
              "185.199.110.153"
              "185.199.111.153"
            }
          }
          new {
            type = "AAAA"
            values {
              "2606:50c0:8000::153"
              "2606:50c0:8001::153"
              "2606:50c0:8002::153"
              "2606:50c0:8003::153"
            }
          }
          new {
            sub = "www"
            type = "CNAME"
            values {
              domainDetails.ghpages!! + ".github.io"
            }
          }
        })
      }
    else
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        when (!domainDetails.records.isEmpty) {
          ...hostedZone(new DomainName { name = apexDomain })
          ...domainRecords(apexDomain, domainDetails.records)
        }
      }


  hidden resources: Mapping<ResourceName, cfn.Resource> = new Mapping<ResourceName, cfn.Resource> {
    ...registerDomainCustomResource

    for (apexDomain, domainDetails in domains) {
      ...apexDomainToResources(apexDomain, domainDetails)
    }
  }

  // output the hostedzones
  hidden outputs: Mapping<String, cfn.Output> = new {
    ...resources
      .toMap()
      .filter((_, resource) -> resource.Type == "AWS::Route53::HostedZone")
      .mapValues((resourceName, resource) -> new cfn.Output {
        Description = "\(resource.Properties["Name"])"
        Value = cfn.Ref(resourceName)
        Export {
           Name = resourceName
        }
      })
  }
}


// typealias RedirectMatcher = "/" | "/*" | "*/"

// class HiddenRedirect {
//   redirectMatcher: RedirectMatcher
//   ammed: String
// }
//
// class PermanentRedirect {
//   redirectMatcher: RedirectMatcher
//   url: String(matches(Regex("https://\(domainNameRegex)")))
// }

const function distributionRecordSets(domainName: DomainName): Mapping<ResourceName, cfn.Resource> =
  new Mapping<ResourceName, cfn.Resource> {
    ["\(domainName.resourceName)RecordSetA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "A"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.apexResourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)RecordSetAAAA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "AAAA"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.apexResourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }
  }

typealias ValidationMethod = "DNS" | "EMAIL"

// todo: option to preserve path
class WebSiteRedirect {

  domainName: DomainName
  redirect: BasicRedirect?
  validationMethod: ValidationMethod

  hidden statusCode = if (redirect.permanent) 301 else 302
  hidden statusDescription = if (redirect.permanent) "Moved Permanently" else "Found"

  hidden redirector: String = """
    function handler(event) {
      return {
        statusCode: \(statusCode),
        statusDescription: '\(statusDescription)',
        headers: {
          'location': { value: '\(redirect.to)' }
        }
      };
    }
    """

  hidden resources: Mapping<ResourceName, cfn.Resource> = new {
    ...hostedZone(domainName)

    ...distributionRecordSets(domainName)

    for (alias in redirect.aliases) {
      ...distributionRecordSets(new DomainName { name = alias })
    }

    ["\(domainName.apexResourceName)Certificate"] = new certificate.Certificate {
      DomainName = domainName.name
      ValidationMethod = validationMethod
      // Adds the validation record to the hostedzone
      DomainValidationOptions {
        new {
          DomainName = domainName.name
          HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
        }
        for (alias in redirect.aliases) {
          new {
            DomainName = alias
            HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
          }
        }
      }
      SubjectAlternativeNames = redirect.aliases
    }

    ["\(domainName.apexResourceName)DistributionFunction"] = new cloudfrontFunction.Function {
      Name = "\(domainName.apexResourceName)Redirect"
      AutoPublish = true
      FunctionCode = redirector
      FunctionConfig {
        Comment = "Redirect-All"
        Runtime = "cloudfront-js-1.0"
      }
    }

    ["\(domainName.apexResourceName)Distribution"] = new distribution.Distribution {
      DistributionConfig {
        Enabled = true
        DefaultCacheBehavior {
          ViewerProtocolPolicy = "redirect-to-https"
          TargetOriginId = "dummy-origin"
          FunctionAssociations {
            new {
              EventType = "viewer-request"
              FunctionARN = cfn.GetAtt("\(domainName.apexResourceName)DistributionFunction.FunctionMetadata", "FunctionARN")
            }
          }
          ForwardedValues {
            QueryString = false
          }
        }
        Origins {
          new {
            Id = "dummy-origin"
            DomainName = domainName.name
            CustomOriginConfig {
              OriginProtocolPolicy = "https-only"
            }
          }
        }
        HttpVersion = "http2"
        Aliases {
          domainName.name
          ...redirect.aliases
        }
        ViewerCertificate {
          AcmCertificateArn = cfn.Ref("\(domainName.apexResourceName)Certificate")
          SslSupportMethod = "sni-only"
        }
      }
    }
  }
}



/*
Data model isn't great. It'd be nice to better model what is valid.
*/
// typealias Redirect = HiddenRedirect | PermanentRedirect

// temporary to avoid unions
class Redirect {
  root: Boolean = false
  trailingSlash: Boolean = false
  everything: Boolean = false
  ammed: String?
  url: String(matches(Regex("https://\(domainNameRegex)")))?
}


// todo: some missing cases
const function redirectToJS(redirect: Redirect): String =
  if (redirect.ammed != null && redirect.root)
    """
    if (uri == '/') {
      request.uri += '\(redirect.ammed)';
    }
    """
  else if (redirect.ammed != null && redirect.trailingSlash)
    """
    if (uri.endsWith('/')) {
      request.uri += '\(redirect.ammed)';
    }
    """
  else if (redirect.url != null && redirect.root)
    """
    if (uri == '/') {
      return {
        statusCode: 301,
        statusDescription: 'Moved Permanently',
        headers: {
          location: { value: '\(redirect.url)' }
        }
      }
    }
    """
  else if (redirect.url != null && redirect.everything)
    """
    if (true) {
      return {
        statusCode: 301,
        statusDescription: 'Moved Permanently',
        headers: {
          location: { value: '\(redirect.url)' + request.path }
        }
      }
    }
    """
  else
    throw("Not Implemented")


const function redirectsToJS(redirects: Listing<Redirect>): String? =
  if (redirects.isEmpty)
    null
  else
    let (ifs = redirects.toList().mapIndexed( (i, redirect) ->
      if (i == 0)
        redirectToJS(redirect)
      else
        "else " + redirectToJS(redirect)
    ))
      """
      function handler(event) {
        var request = event.request;
        var uri = request.uri;
        \(ifs)
        return request;
      }
      """

class WebSite {

  domainName: DomainName

  redirects: Listing<Redirect>

  hidden redirector: String? = redirectsToJS(redirects)

  hidden bucket = "\(domainName.resourceName)WebsiteBucket"

  hidden resources: Mapping<ResourceName, cfn.Resource> = new {
    ["\(domainName.apexResourceName)HostedZone"] = new hostedzone.HostedZone {
      Name = domainName.apex
    }

    ["\(domainName.resourceName)RecordSetA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "A"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.resourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)RecordSetAAAA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "AAAA"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.resourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)Certificate"] = new certificate.Certificate {
      DomainName = domainName.name
      ValidationMethod = "DNS"
      // Adds the validation record to the hostedzone?
      DomainValidationOptions {
        new {
          DomainName = domainName.name
          HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
        }
      }
    }

    [bucket] = new bucket.Bucket {
      BucketName = domainName.name
      AccessControl = "Private"
    }

    ["\(domainName.resourceName)BucketPolicy"] = new bucketpolicy.BucketPolicy {
      Bucket = cfn.Ref("\(domainName.resourceName)WebsiteBucket")
      PolicyDocument {
        Version = "2012-10-17"
        Statement {
          new {
            Action = "s3:GetObject"
            Principal {
              Service = "cloudfront.amazonaws.com"
            }
            Resource = cfn.Sub("arn:aws:s3:::${\(domainName.resourceName)WebsiteBucket}/*")
            Effect = "Allow"
            Condition {
              StringEquals {
                `AWS:SourceArn` = cfn.Sub("arn:aws:cloudfront::${AWS::AccountId}:distribution/${\(domainName.resourceName)Distribution.Id}")
              }
            }
          }
        }
      }
    }

    ["\(domainName.resourceName)OriginAccessControl"] = new originaccesscontrol.OriginAccessControl {
      OriginAccessControlConfig {
        Name = "\(domainName.resourceName)OriginAccessControl"
        OriginAccessControlOriginType = "s3"
        SigningBehavior = "always"
        SigningProtocol = "sigv4"
      }
    }

    when (redirector != null) {
      ["\(domainName.resourceName)DistributionFunction"] = new cloudfrontFunction.Function {
        Name = "\(domainName.resourceName)RedirectDefaultIndexRequest"
        AutoPublish = true
        FunctionCode = redirector
        FunctionConfig {
          Comment = "Redirect-Default-Index-Request"
          Runtime = "cloudfront-js-1.0"
        }
      }
    }

    ["\(domainName.resourceName)Distribution"] = new distribution.Distribution {
      DistributionConfig {
        Enabled = true
        DefaultRootObject = "index.html"
        DefaultCacheBehavior {
          AllowedMethods {
            "GET"
            "HEAD"
          }
          Compress = true
          DefaultTTL = 86400
          ForwardedValues {
            QueryString = true
          }
          MaxTTL = 31536000
          ViewerProtocolPolicy = "redirect-to-https"
          TargetOriginId = "WebOrigin"

          when (redirector != null) {
            FunctionAssociations {
              new {
                EventType = "viewer-request"
                FunctionARN = cfn.GetAtt("\(domainName.resourceName)DistributionFunction.FunctionMetadata", "FunctionARN")
              }
            }
          }
        }
        HttpVersion = "http2"
        Aliases {
          domainName.name
        }
        ViewerCertificate {
          AcmCertificateArn = cfn.Ref("\(domainName.resourceName)Certificate")
          SslSupportMethod = "sni-only"
        }
        Origins {
          new {
            Id = "WebOrigin"
            DomainName = cfn.GetAtt("\(domainName.resourceName)WebsiteBucket", "RegionalDomainName")
            // it seems this must be specified but empty?
            S3OriginConfig { }
            OriginAccessControlId = cfn.GetAtt("\(domainName.resourceName)OriginAccessControl", "Id")
          }
        }
      }
    }
  }
}
