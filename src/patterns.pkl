module `cfn-pkl-extras`.patterns

import "pkl:Project"
import "@cfn/cloudformation.pkl" as cfn
import "@cfn/aws/lambda/function.pkl" as lambdafunction
// import "@cfn/patterns/role.pkl" as role
import "@cfn/aws/iam/role.pkl" as role
import "@cfn/aws/route53/recordset.pkl" as recordset
import "@cfn/aws/route53/hostedzone.pkl" as hostedzone
import "@cfn/aws/s3/bucket.pkl" as bucket
import "@cfn/aws/s3/bucketpolicy.pkl" as bucketpolicy
import "@cfn/aws/cloudfront/distribution.pkl" as distribution
import "@cfn/aws/cloudfront/originaccesscontrol.pkl" as originaccesscontrol
import "@cfn/aws/cloudfront/function.pkl" as cloudfrontFunction
import "@cfn/aws/certificatemanager/certificate.pkl" as certificate
// import "package://pkg.pkl-lang.org/github.com/aws-cloudformation/cloudformation-pkl/cloudformation@0.1.4#/aws/certificatemanager/certificate.pkl" as certificate
import "route53.pkl" as route53

// todo: must not start with a number?
const resourceNameClases = "A-Za-z0-9"
const resourceNameRegex = Regex("[\(resourceNameClases)]+")
const resourceNameInvalidRegex = Regex("[^\(resourceNameClases)]")

typealias ResourceName = String(matches(resourceNameRegex), length < 256)


class DomainTemplate {
  resources: Mapping<ResourceName, cfn.Resource>
  outputs: Mapping<ResourceName, cfn.Output>
}


class BasicRedirect {
  sub: String?
  to: Uri
  permanent: Boolean = false
  aliases: Listing<route53.ValidDomainName>
}


// todo: can't have ghpages and redirect
class DomainDetails {
  authCode: (String | Mapping)?
  redirect: BasicRedirect?
  ghpages: String?
  records: Listing<route53.DomainRecord>
  nameServers: Listing<route53.ValidDomainName>
  autoRenew: Boolean = true
}


class Domains {
  contact: route53.Contact
  domains: Mapping<route53.ApexDomainName, DomainDetails>

  function apexDomainToDomain(apexDomain: route53.ApexDomainName, domainDetails: DomainDetails): route53.Domain =
    let (_contact = contact)
      new route53.Domain {
        domainName {
          name = apexDomain
        }
        contact = _contact
        transferAuthCode = domainDetails.authCode
        // todo: the way we set the nameservers is brittle
        nameServers = if (domainDetails.nameServers.isEmpty && (domainDetails.redirect != null || domainDetails.ghpages != null || !domainDetails.records.isEmpty))
            cfn.GetAtt("\(domainName.apexResourceName)HostedZone", "NameServers")
          else
            domainDetails.nameServers
        autoRenew = domainDetails.autoRenew
      }

  function apexDomainToResources(apexDomain: route53.ApexDomainName, domainDetails: DomainDetails): Mapping<ResourceName, cfn.Resource> =
    if (domainDetails.redirect != null)
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        ...new WebSiteRedirect {
          domainName {
            name = domainDetails.redirect?.sub.ifNonNull((sub) -> "\(sub).\(apexDomain)") ?? apexDomain
          }
          redirect = domainDetails.redirect
          validationMethod = if (domainDetails.authCode != null) "EMAIL" else "DNS" // transferring domains takes a long time, blocking certification creation
        }.resources
        when (!domainDetails.records.isEmpty) {
          ...route53.domainRecords(apexDomain, domainDetails.records)
        }
      }
    else if (domainDetails.ghpages != null)
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        ...route53.hostedZone(new route53.DomainName { name = apexDomain })
        ...route53.domainRecords(apexDomain, new Listing<route53.DomainRecord> {
          new {
            type = "A"
            values {
              "185.199.108.153"
              "185.199.109.153"
              "185.199.110.153"
              "185.199.111.153"
            }
          }
          new {
            type = "AAAA"
            values {
              "2606:50c0:8000::153"
              "2606:50c0:8001::153"
              "2606:50c0:8002::153"
              "2606:50c0:8003::153"
            }
          }
          new {
            sub = "www"
            type = "CNAME"
            values {
              domainDetails.ghpages!! + ".github.io"
            }
          }
        })
      }
    else
      new {
        ...apexDomainToDomain(apexDomain, domainDetails).resources
        when (!domainDetails.records.isEmpty) {
          ...route53.hostedZone(new route53.DomainName { name = apexDomain })
          ...route53.domainRecords(apexDomain, domainDetails.records)
        }
      }


  hidden resources: Mapping<ResourceName, cfn.Resource> = new Mapping<ResourceName, cfn.Resource> {
    ...route53.domainCustomResource.resources

    ...route53.hostedZoneCustomResource.resources

    for (apexDomain, domainDetails in domains) {
      ...apexDomainToResources(apexDomain, domainDetails)
    }
  }

  // output the hostedzones
  hidden outputs: Mapping<String, cfn.Output> = new {
    ...resources
      .toMap()
      .filter((_, resource) -> resource.Type == "AWS::Route53::HostedZone")
      .mapValues((resourceName, resource) -> new cfn.Output {
        Description = "\(resource.Properties["Name"])"
        Value = cfn.Ref(resourceName)
        Export {
           Name = resourceName
        }
      })
  }
}

// typealias RedirectMatcher = "/" | "/*" | "*/"

// class HiddenRedirect {
//   redirectMatcher: RedirectMatcher
//   ammed: String
// }
//
// class PermanentRedirect {
//   redirectMatcher: RedirectMatcher
//   url: String(matches(Regex("https://\(domainNameRegex)")))
// }

const function distributionRecordSets(domainName: route53.DomainName): Mapping<ResourceName, cfn.Resource> =
  new Mapping<ResourceName, cfn.Resource> {
    ["\(domainName.resourceName)RecordSetA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "A"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.apexResourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)RecordSetAAAA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "AAAA"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.apexResourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }
  }

typealias ValidationMethod = "DNS" | "EMAIL"

// todo: option to preserve path
class WebSiteRedirect {

  domainName: route53.DomainName
  redirect: BasicRedirect?
  validationMethod: ValidationMethod

  hidden statusCode = if (redirect.permanent) 301 else 302
  hidden statusDescription = if (redirect.permanent) "Moved Permanently" else "Found"

  hidden redirector: String = """
    function handler(event) {
      return {
        statusCode: \(statusCode),
        statusDescription: '\(statusDescription)',
        headers: {
          'location': { value: '\(redirect.to)' }
        }
      };
    }
    """

  hidden resources: Mapping<ResourceName, cfn.Resource> = new {
    ...route53.hostedZone(domainName)

    ...distributionRecordSets(domainName)

    for (alias in redirect.aliases) {
      ...distributionRecordSets(new route53.DomainName { name = alias })
    }

    ["\(domainName.apexResourceName)Certificate"] = new certificate.Certificate {
      DomainName = domainName.name
      ValidationMethod = validationMethod
      // Adds the validation record to the hostedzone
      DomainValidationOptions {
        new {
          DomainName = domainName.name
          HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
        }
        for (alias in redirect.aliases) {
          new {
            DomainName = alias
            HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
          }
        }
      }
      SubjectAlternativeNames = redirect.aliases
    }

    ["\(domainName.apexResourceName)DistributionFunction"] = new cloudfrontFunction.Function {
      Name = "\(domainName.apexResourceName)Redirect"
      AutoPublish = true
      FunctionCode = redirector
      FunctionConfig {
        Comment = "Redirect-All"
        Runtime = "cloudfront-js-1.0"
      }
    }

    ["\(domainName.apexResourceName)Distribution"] = new distribution.Distribution {
      DistributionConfig {
        Enabled = true
        DefaultCacheBehavior {
          ViewerProtocolPolicy = "redirect-to-https"
          TargetOriginId = "dummy-origin"
          FunctionAssociations {
            new {
              EventType = "viewer-request"
              FunctionARN = cfn.GetAtt("\(domainName.apexResourceName)DistributionFunction.FunctionMetadata", "FunctionARN")
            }
          }
          ForwardedValues {
            QueryString = false
          }
        }
        Origins {
          new {
            Id = "dummy-origin"
            DomainName = domainName.name
            CustomOriginConfig {
              OriginProtocolPolicy = "https-only"
            }
          }
        }
        HttpVersion = "http2"
        Aliases {
          domainName.name
          ...redirect.aliases
        }
        ViewerCertificate {
          AcmCertificateArn = cfn.Ref("\(domainName.apexResourceName)Certificate")
          SslSupportMethod = "sni-only"
        }
      }
    }
  }
}


class DNS {

  domains: Mapping<route53.ApexDomainName, Listing<route53.DomainRecord>>

  hidden resources: Mapping<ResourceName, cfn.Resource> =
    new Mapping<ResourceName, cfn.Resource> {
      for (apexDomainName, domainValue in domains) {
        // todo: nicer way to convert ApexDomainName to ResourceName
        ["\(new route53.DomainName { name = apexDomainName }.apexResourceName)HostedZone"] = new hostedzone.HostedZone {
          Name = apexDomainName
        }

        ...route53.domainRecords(apexDomainName, domainValue)
      }
    }

  hidden outputs: Mapping<String, cfn.Output> = new {
    ...resources
      .toMap()
      .filter((_, resource) -> resource.Type == "AWS::Route53::HostedZone")
      .mapValues((resourceName, resource) -> new cfn.Output {
        Description = "\(resource.Properties["Name"])"
        Value = cfn.Ref(resourceName)
        Export {
          Name = resourceName
        }
      })
  }
}


/*
Data model isn't great. It'd be nice to better model what is valid.
*/
// typealias Redirect = HiddenRedirect | PermanentRedirect

/*
// temporary to avoid unions
class Redirect {
  root: Boolean = false
  trailingSlash: Boolean = false
  everything: Boolean = false
  ammed: String?
  url: String(matches(Regex("https://\(domainNameRegex)")))?
}
*/


/*
// todo: some missing cases
const function redirectToJS(redirect: Redirect): String =
  if (redirect.ammed != null && redirect.root)
    """
    if (uri == '/') {
      request.uri += '\(redirect.ammed)';
    }
    """
  else if (redirect.ammed != null && redirect.trailingSlash)
    """
    if (uri.endsWith('/')) {
      request.uri += '\(redirect.ammed)';
    }
    """
  else if (redirect.url != null && redirect.root)
    """
    if (uri == '/') {
      return {
        statusCode: 301,
        statusDescription: 'Moved Permanently',
        headers: {
          location: { value: '\(redirect.url)' }
        }
      }
    }
    """
  else if (redirect.url != null && redirect.everything)
    """
    if (true) {
      return {
        statusCode: 301,
        statusDescription: 'Moved Permanently',
        headers: {
          location: { value: '\(redirect.url)' + request.path }
        }
      }
    }
    """
  else
    throw("Not Implemented")


const function redirectsToJS(redirects: Listing<Redirect>): String? =
  if (redirects.isEmpty)
    null
  else
    let (ifs = redirects.toList().mapIndexed( (i, redirect) ->
      if (i == 0)
        redirectToJS(redirect)
      else
        "else " + redirectToJS(redirect)
    ))
      """
      function handler(event) {
        var request = event.request;
        var uri = request.uri;
        \(ifs)
        return request;
      }
      """
*/

/*
class WebSite {

  domainName: DomainName

  redirects: Listing<Redirect>

  hidden redirector: String? = redirectsToJS(redirects)

  hidden bucket = "\(domainName.resourceName)WebsiteBucket"

  hidden resources: Mapping<ResourceName, cfn.Resource> = new {
    ["\(domainName.apexResourceName)HostedZone"] = new hostedzone.HostedZone {
      Name = domainName.apex
    }

    ["\(domainName.resourceName)RecordSetA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "A"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.resourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)RecordSetAAAA"] = new recordset.RecordSet {
      HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
      Name = domainName.name
      TypeProperty = "AAAA"
      AliasTarget {
        // The following HosteZoneId is always used for alias records pointing to CF.
        HostedZoneId = "Z2FDTNDATAQYW2"
        //HostedZoneId = cfn.GetAtt("Distribution", "HostedZoneId")
        DNSName = cfn.GetAtt("\(domainName.resourceName)Distribution", "DomainName")
        EvaluateTargetHealth = false
      }
    }

    ["\(domainName.resourceName)Certificate"] = new certificate.Certificate {
      DomainName = domainName.name
      ValidationMethod = "DNS"
      // Adds the validation record to the hostedzone?
      DomainValidationOptions {
        new {
          DomainName = domainName.name
          HostedZoneId = cfn.Ref("\(domainName.apexResourceName)HostedZone")
        }
      }
    }

    [bucket] = new bucket.Bucket {
      BucketName = domainName.name
      AccessControl = "Private"
    }

    ["\(domainName.resourceName)BucketPolicy"] = new bucketpolicy.BucketPolicy {
      Bucket = cfn.Ref("\(domainName.resourceName)WebsiteBucket")
      PolicyDocument {
        Version = "2012-10-17"
        Statement {
          new {
            Action = "s3:GetObject"
            Principal {
              Service = "cloudfront.amazonaws.com"
            }
            Resource = cfn.Sub("arn:aws:s3:::${\(domainName.resourceName)WebsiteBucket}/*")
            Effect = "Allow"
            Condition {
              StringEquals {
                `AWS:SourceArn` = cfn.Sub("arn:aws:cloudfront::${AWS::AccountId}:distribution/${\(domainName.resourceName)Distribution.Id}")
              }
            }
          }
        }
      }
    }

    ["\(domainName.resourceName)OriginAccessControl"] = new originaccesscontrol.OriginAccessControl {
      OriginAccessControlConfig {
        Name = "\(domainName.resourceName)OriginAccessControl"
        OriginAccessControlOriginType = "s3"
        SigningBehavior = "always"
        SigningProtocol = "sigv4"
      }
    }

    when (redirector != null) {
      ["\(domainName.resourceName)DistributionFunction"] = new cloudfrontFunction.Function {
        Name = "\(domainName.resourceName)RedirectDefaultIndexRequest"
        AutoPublish = true
        FunctionCode = redirector
        FunctionConfig {
          Comment = "Redirect-Default-Index-Request"
          Runtime = "cloudfront-js-1.0"
        }
      }
    }

    ["\(domainName.resourceName)Distribution"] = new distribution.Distribution {
      DistributionConfig {
        Enabled = true
        DefaultRootObject = "index.html"
        DefaultCacheBehavior {
          AllowedMethods {
            "GET"
            "HEAD"
          }
          Compress = true
          DefaultTTL = 86400
          ForwardedValues {
            QueryString = true
          }
          MaxTTL = 31536000
          ViewerProtocolPolicy = "redirect-to-https"
          TargetOriginId = "WebOrigin"

          when (redirector != null) {
            FunctionAssociations {
              new {
                EventType = "viewer-request"
                FunctionARN = cfn.GetAtt("\(domainName.resourceName)DistributionFunction.FunctionMetadata", "FunctionARN")
              }
            }
          }
        }
        HttpVersion = "http2"
        Aliases {
          domainName.name
        }
        ViewerCertificate {
          AcmCertificateArn = cfn.Ref("\(domainName.resourceName)Certificate")
          SslSupportMethod = "sni-only"
        }
        Origins {
          new {
            Id = "WebOrigin"
            DomainName = cfn.GetAtt("\(domainName.resourceName)WebsiteBucket", "RegionalDomainName")
            // it seems this must be specified but empty?
            S3OriginConfig { }
            OriginAccessControlId = cfn.GetAtt("\(domainName.resourceName)OriginAccessControl", "Id")
          }
        }
      }
    }
  }
}
*/
